// ----- DIRECTORY STRUCTURE: frontend -----
frontend
â”œâ”€â”€ README.md
â”œâ”€â”€ eslint.config.js
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ public
â”‚Â Â  â””â”€â”€ vite.svg
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ App.css
â”‚Â Â  â”œâ”€â”€ App.tsx
â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â””â”€â”€ react.svg
â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â””â”€â”€ useRealTimeData.ts
â”‚Â Â  â”œâ”€â”€ index.css
â”‚Â Â  â”œâ”€â”€ main.tsx
â”‚Â Â  â””â”€â”€ types
â”‚Â Â      â””â”€â”€ index.ts
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ tsconfig.app.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.node.json
â””â”€â”€ vite.config.ts

6 directories, 18 files

// ----- START FILE: frontend/tsconfig.node.json -----
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": [
      "ES2023"
    ],
    "module": "ESNext",
    "types": [
      "node"
    ],
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": [
    "vite.config.ts"
  ]
}
// ----- END FILE: frontend/tsconfig.node.json -----

// ----- START FILE: frontend/index.html -----
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>frontend</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
// ----- END FILE: frontend/index.html -----

// ----- START FILE: frontend/tailwind.config.js -----
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // <-- Ye line components ko scan karegi
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
// ----- END FILE: frontend/tailwind.config.js -----

// ----- START FILE: frontend/tsconfig.app.json -----
// {
//   "compilerOptions": {
//     "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
//     "target": "ES2022",
//     "useDefineForClassFields": true,
//     "lib": [
//       "ES2022",
//       "DOM",
//       "DOM.Iterable"
//     ],
//     "module": "ESNext",
//     "types": [
//       "vite/client"
//     ],
//     "skipLibCheck": true,
//     /* Bundler mode */
//     "moduleResolution": "bundler",
//     "allowImportingTsExtensions": true,
//     "verbatimModuleSyntax": true,
//     "moduleDetection": "force",
//     "noEmit": true,
//     "jsx": "react-jsx",
//     /* Linting */
//     "strict": true,
//     "noUnusedLocals": true,
//     "noUnusedParameters": true,
//     "noFallthroughCasesInSwitch": true,
//     "noUncheckedSideEffectImports": true
//   },
//   "include": [
//     "src"
//   ]
// }
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "skipLibCheck": true,
    /* Required for Vite */
    "moduleResolution": "bundler",
    /* IMPORTANT FIX */
    "verbatimModuleSyntax": false,
    /* OK to keep */
    "allowImportingTsExtensions": true,
    /* Good optimizations */
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  },
  "include": [
    "src"
  ]
}
// ----- END FILE: frontend/tsconfig.app.json -----

// ----- START FILE: frontend/README.md -----
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

// ----- END FILE: frontend/README.md -----

// ----- START FILE: frontend/public/vite.svg -----
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
// ----- END FILE: frontend/public/vite.svg -----

// ----- START FILE: frontend/.gitignore -----
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

// ----- END FILE: frontend/.gitignore -----

// ----- START FILE: frontend/package.json -----
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "framer-motion": "^12.23.24",
    "lucide-react": "^0.554.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.0",
    "@types/react": "^19.2.2",
    "@types/react-dom": "^19.2.2",
    "@vitejs/plugin-react": "^5.1.0",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.3",
    "vite": "^7.2.2"
  }
}

// ----- END FILE: frontend/package.json -----

// ----- START FILE: frontend/tsconfig.json -----
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

// ----- END FILE: frontend/tsconfig.json -----

// ----- START FILE: frontend/eslint.config.js -----
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])

// ----- END FILE: frontend/eslint.config.js -----

// ----- START FILE: frontend/vite.config.ts -----
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from 'tailwindcss' // <--- New Import
import autoprefixer from 'autoprefixer' // <--- New Import

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  css: {
    postcss: {
      plugins: [tailwindcss, autoprefixer], // <-- FIX: Tailwind plugins add kiye
    },
  },
})
// ----- END FILE: frontend/vite.config.ts -----

// ----- START FILE: frontend/postcss.config.js -----
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// ----- END FILE: frontend/postcss.config.js -----

// ----- START FILE: frontend/src/App.tsx -----
import { ArrowUp, ArrowDown, CircleDot } from 'lucide-react';
import { useRealTimeData } from './hooks/useRealTimeData';
import { motion } from 'framer-motion';

const formatChange = (change: number) => {
  const isPositive = change > 0;
  const color = isPositive ? 'text-green-500' : 'text-red-500';
  const Icon = isPositive ? ArrowUp : ArrowDown;

  return (
    <span className={`${color} flex items-center`}>
      {change.toFixed(2)}% <Icon size={14} className="ml-1" />
    </span>
  );
};

function App() {
  const { tokens, isConnected } = useRealTimeData();

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 p-8">
      <header className="mb-8">
        <h1 className="text-4xl font-extrabold text-indigo-400 flex items-center">
          ğŸ”¥ Meme Coin Aggregator
          <span className="text-xl ml-4 font-normal text-gray-400">(Live Updates)</span>
        </h1>
        <div className="mt-2 text-sm flex items-center">
          <CircleDot size={16} className={`mr-2 ${isConnected ? 'text-green-500' : 'text-yellow-500'}`} />
          Status: {isConnected ? 'Real-time Connected' : 'Connecting...'}
        </div>
      </header>

      <div className="overflow-x-auto shadow-xl rounded-lg">
        <table className="min-w-full divide-y divide-gray-700">
          <thead className="bg-gray-800">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Token</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Price (SOL)</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">1h Change</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">24h Volume</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Total Liquidity</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Sources</th>
            </tr>
          </thead>

          <tbody className="divide-y divide-gray-800">
            {tokens.length === 0 ? (
              <tr>
                <td colSpan={6} className="text-center py-4 text-gray-500">
                  Waiting for data from workers...
                </td>
              </tr>
            ) : (
              tokens.map((token) => (
                // âœ… FIX: Plain <tr> use kiya
                <tr key={token.token_address} className="bg-gray-900 hover:bg-gray-700 transition-colors">
                  <td className="px-6 py-4">
                    <div className="text-white font-medium">{token.token_ticker}</div>
                    <div className="text-gray-400 text-xs truncate w-32">{token.token_name}</div>
                  </td>

                  <td className="px-6 py-4">
                    {/* âœ… FIX: key={price} hata kar layout use kiya, taaki smooth update ho */}
                    <motion.div
                      layout
                      initial={{ opacity: 0.3 }}
                      animate={{ opacity: 1 }}
                      transition={{ duration: 0.4 }}
                    >
                      {token.price_sol.toPrecision(6)}
                    </motion.div>
                  </td>

                  <td className="px-6 py-4">{formatChange(token.price_1hr_change || 0)}</td>

                  <td className="px-6 py-4 text-gray-300">SOL {token.volume_sol.toFixed(2)}</td>

                  <td className="px-6 py-4 text-gray-300">SOL {token.liquidity_sol.toFixed(0)}</td>

                  <td className="px-6 py-4 text-gray-400 text-xs">
                    {token.protocol.split(', ').slice(0, 2).join(', ')}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      <footer className="mt-8 text-center text-xs text-gray-500">
        Data refreshed via BullMQ Worker every 30s. Updates pushed via Redis Pub/Sub & Socket.io.
      </footer>
    </div>
  );
}

export default App;
// ----- END FILE: frontend/src/App.tsx -----

// ----- START FILE: frontend/src/main.tsx -----
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

// ----- END FILE: frontend/src/main.tsx -----

// ----- START FILE: frontend/src/types/index.ts -----
export interface TokenData {
    token_address: string;
    token_name: string;
    token_ticker: string;
    price_sol: number;
    market_cap_sol: number;
    volume_sol: number;
    liquidity_sol: number;
    transaction_count: number;
    price_1hr_change?: number;
    protocol: string;
}
// ----- END FILE: frontend/src/types/index.ts -----

// ----- START FILE: frontend/src/App.css -----
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

// ----- END FILE: frontend/src/App.css -----

// ----- START FILE: frontend/src/index.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;
// ----- END FILE: frontend/src/index.css -----

// ----- START FILE: frontend/src/hooks/useRealTimeData.ts -----
import { useState, useEffect } from 'react';
import { io } from 'socket.io-client';
// Backend se copy kiye gaye types ko yahan import karo
import { TokenData } from '../types/index.ts';

// Initial empty data state
const initialData: TokenData[] = [];

export const useRealTimeData = () => {
    const [tokens, setTokens] = useState<TokenData[]>(initialData);
    const [isConnected, setIsConnected] = useState(false);

    useEffect(() => {
        // NOTE: Ye URL wohi hona chahiye jahan tumhara Fastify server chal raha hai
        const socket = io('http://localhost:4000');

        socket.on('connect', () => {
            console.log("Socket: Connected!");
            setIsConnected(true);

            // Server ko batao ki hum discover room join kar rahe hain
            socket.emit('join_discover_room');

            fetch('http://localhost:4000/api/v1/discover?limit=20&sort=volume_sol')
                .then(res => res.json())
                .then(data => {
                    if (data.data) {
                        setTokens(data.data);
                    }
                })
                .catch(error => console.error("Initial REST Fetch Failed:", error));
        });

        socket.on('token_update', (newToken: TokenData) => {
            console.log(`Socket: Received update for ${newToken.token_ticker}`);

            setTokens(prevTokens => {
                // Check if token already exists (by token_address)
                const exists = prevTokens.find(t => t.token_address === newToken.token_address);

                if (exists) {
                    // Agar exist karta hai, toh update karo (Delta-only update logic)
                    return prevTokens.map(t =>
                        t.token_address === newToken.token_address ? { ...t, ...newToken } : t
                    );
                } else {
                    // Agar naya token hai, toh list mein add karo
                    return [...prevTokens, newToken];
                }
            });
        });

        socket.on('disconnect', () => {
            console.log("Socket: Disconnected!");
            setIsConnected(false);
        });

        // Cleanup function
        return () => {
            socket.disconnect();
        };
    }, []);

    // Hum tokens ko Volume ke hisaab se sort karenge taaki demo achha lage
    const sortedTokens = [...tokens].sort((a, b) => b.volume_sol - a.volume_sol);

    return { tokens: sortedTokens, isConnected };
};

// ----- END FILE: frontend/src/hooks/useRealTimeData.ts -----

// ----- START FILE: frontend/src/assets/react.svg -----
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
// ----- END FILE: frontend/src/assets/react.svg -----

// ----- DIRECTORY STRUCTURE: backend -----
backend
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ jest.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app.ts
â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â””â”€â”€ env.ts
â”‚Â Â  â”œâ”€â”€ queues
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ connection.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ tokenQueue.ts
â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â  â”‚Â Â  â””â”€â”€ discover.ts
â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ aggregator.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ dexProvider.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ tokenDiscovery.ts
â”‚Â Â  â”œâ”€â”€ sockets
â”‚Â Â  â”‚Â Â  â””â”€â”€ socketManager.ts
â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ utils
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pagination.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ redis.ts
â”‚Â Â  â””â”€â”€ workers
â”‚Â Â      â””â”€â”€ fetchWorker.ts
â”œâ”€â”€ tests
â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â””â”€â”€ aggregator.test.ts
â”‚Â Â  â””â”€â”€ utils
â”‚Â Â      â””â”€â”€ pagination.test.ts
â””â”€â”€ tsconfig.json

13 directories, 20 files

// ----- START FILE: backend/Dockerfile -----
# Stage 1: Build Stage (Dependencies install karna)
FROM node:20-alpine AS builder

# Set working directory inside the container
WORKDIR /app/backend

# Copy package.json and install dependencies
COPY package.json .
COPY package-lock.json .
RUN npm install

# Copy source code and Build (TS compilation)
COPY . .
RUN npm run build # <--- Ye line zaroori hai production (dist) folder banane ke liye

# Stage 2: Production Setup (Lightweight runtime)
FROM node:20-alpine

# Set working directory
WORKDIR /app/backend

# Copy only necessary production files
COPY --from=builder /app/backend/node_modules ./node_modules
COPY --from=builder /app/backend/dist ./dist 
COPY --from=builder /app/backend/package.json .
COPY --from=builder /app/backend/.env .

# Expose the port where Fastify will run
EXPOSE 4000

# Set environment variable 
ENV NODE_ENV production

# CMD ko Render service mein define karenge
CMD ["node", "dist/app.js"]
// ----- END FILE: backend/Dockerfile -----

// ----- START FILE: backend/jest.config.js -----
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    // Test files ko .test.ts extension se pehchana jayega
    testMatch: ["**/tests/**/*.test.ts"],
    // Src folder mein tests run honge
    rootDir: './',
    modulePaths: ["<rootDir>/src"],
    moduleFileExtensions: ["ts", "js"],
    // Coverage report kahan save hoga
    collectCoverageFrom: ["src/**/*.ts", "!src/server.ts", "!src/app.ts", "!src/utils/redis.ts"],
};
// ----- END FILE: backend/jest.config.js -----

// ----- START FILE: backend/tests/utils/pagination.test.ts -----
import { applyCursorPagination } from '../../src/utils/pagination';
import { TokenData } from '../../src/types';

// Sample data (sorted by volume_sol descending)
const mockTokens: TokenData[] = [
    { token_address: 'A', token_ticker: 'A', volume_sol: 1000 } as TokenData,
    { token_address: 'B', token_ticker: 'B', volume_sol: 800 } as TokenData,
    { token_address: 'C', token_ticker: 'C', volume_sol: 600 } as TokenData,
    { token_address: 'D', token_ticker: 'D', volume_sol: 400 } as TokenData,
    { token_address: 'E', token_ticker: 'E', volume_sol: 200 } as TokenData,
];

describe('Cursor Pagination Utility Tests', () => {

    // Helper function to encode address to cursor
    const encode = (address: string) => Buffer.from(address).toString('base64');

    test('should return the first page correctly', () => {
        const result = applyCursorPagination(mockTokens, 2, undefined);

        expect(result.data.length).toBe(2);
        expect(result.data[0].token_ticker).toBe('A');
        expect(result.data[1].token_ticker).toBe('B');

        // Next cursor should point to the last element of the current page (B)
        expect(result.next_cursor).toBe(encode('B'));
    });

    test('should return the second page using cursor', () => {
        const cursorB = encode('B'); // Cursor is the address of token B

        const result = applyCursorPagination(mockTokens, 2, cursorB);

        expect(result.data.length).toBe(2);
        expect(result.data[0].token_ticker).toBe('C');
        expect(result.data[1].token_ticker).toBe('D');

        expect(result.next_cursor).toBe(encode('D'));
    });

    test('should handle the last page correctly', () => {
        const cursorD = encode('D');

        const result = applyCursorPagination(mockTokens, 2, cursorD);

        expect(result.data.length).toBe(1); // Only token E remains
        expect(result.data[0].token_ticker).toBe('E');

        expect(result.next_cursor).toBeNull(); // No next page
    });

    test('should handle limit larger than array size', () => {
        const result = applyCursorPagination(mockTokens, 50, undefined);
        expect(result.data.length).toBe(5);
        expect(result.next_cursor).toBeNull();
    });
});
// ----- END FILE: backend/tests/utils/pagination.test.ts -----

// ----- START FILE: backend/tests/services/aggregator.test.ts -----
import { mergeTokenData } from '../../src/services/aggregator';
import { TokenData } from '../../src/types';

describe('Aggregator Service Tests', () => {
    // Sample Data: Same token (MOODENG SOL) on 3 different DEXs
    const mockTokenA: TokenData = {
        token_address: 'TOKEN_MOODENG_SOL',
        token_name: 'Moo Deng',
        token_ticker: 'MOODENG',
        price_sol: 0.000010,
        market_cap_sol: 1000,
        volume_sol: 50,
        liquidity_sol: 500, // Highest Liquidity
        transaction_count: 0,
        price_1hr_change: -1.0,
        protocol: 'Raydium'
    };

    const mockTokenB: TokenData = {
        token_address: 'TOKEN_MOODENG_SOL',
        token_name: 'Moo Deng',
        token_ticker: 'MOODENG',
        price_sol: 0.000008, // Lower Price
        market_cap_sol: 800,
        volume_sol: 30,
        liquidity_sol: 200,
        transaction_count: 0,
        price_1hr_change: 2.5, // Best Price Change
        protocol: 'Orca'
    };

    const mockTokenC: TokenData = {
        token_address: 'TOKEN_MOODENG_SOL',
        token_name: 'Moo Deng',
        token_ticker: 'MOODENG',
        price_sol: 0.000012, // Highest Price, Low Liquidity
        market_cap_sol: 1200,
        volume_sol: 20,
        liquidity_sol: 100,
        transaction_count: 0,
        price_1hr_change: 0.5,
        protocol: 'Meteora'
    };

    test('should correctly merge data from multiple sources', () => {
        const merged = mergeTokenData([mockTokenA, mockTokenB, mockTokenC]);

        expect(merged).not.toBeNull();
        if (!merged) return;

        // 1. Total Volume should be summed up (50 + 30 + 20 = 100)
        expect(merged.volume_sol).toBe(100);

        // 2. Total Liquidity should be summed up (500 + 200 + 100 = 800)
        expect(merged.liquidity_sol).toBe(800);

        // 3. Price should be selected from the source with the HIGHEST liquidity (Mock A: 500 liquidity, Price: 0.000010)
        expect(merged.price_sol).toBe(0.000010);

        // 4. Protocols should be merged
        expect(merged.protocol).toContain('Raydium, Orca, Meteora');
    });

    test('should return null if array is empty', () => {
        expect(mergeTokenData([])).toBeNull();
    });
});
// ----- END FILE: backend/tests/services/aggregator.test.ts -----

// ----- START FILE: backend/package.json -----
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/app.ts",
    "build": "tsc",
    "test": "jest",
    "start": "node dist/app.js",
    "worker": "ts-node src/workers/fetchWorker.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@fastify/cors": "^11.1.0",
    "@socket.io/redis-adapter": "^8.3.0",
    "bottleneck": "^2.19.5",
    "bullmq": "^5.63.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "fastify": "^5.6.2",
    "got": "^11.8.6",
    "ioredis": "^5.8.2",
    "mongoose": "^8.20.0",
    "node-cron": "^4.2.1",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1"
  },
  "devDependencies": {
    "@types/got": "^9.6.12",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.10.1",
    "@types/node-cron": "^3.0.11",
    "@types/socket.io": "^3.0.1",
    "@types/socket.io-client": "^1.4.36",
    "@types/ws": "^8.18.1",
    "jest": "^30.2.0",
    "nodemon": "^3.1.11",
    "ts-jest": "^29.4.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
// ----- END FILE: backend/package.json -----

// ----- START FILE: backend/.env -----
PORT=4000
REDIS_URL=redis://localhost:6379
# Agar DexScreener key ki zaroorat ho future mein toh yahan aayegi, abhi khali chhodo
NODE_ENV=development
// ----- END FILE: backend/.env -----

// ----- START FILE: backend/tsconfig.json -----
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "rootDir": "./src",
    "moduleResolution": "node",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}
// ----- END FILE: backend/tsconfig.json -----

// ----- START FILE: backend/docker-compose.yml -----
version: '3.8'

services:
  redis:
    image: redis:alpine
    container_name: meme_redis
    ports:
      - "6379:6379"
    restart: always

  server:
    build: .
    container_name: meme_aggregator_api
    depends_on:
      - redis
    ports:
      - "4000:4000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - REDIS_URL=redis://redis:6379 # Internal Docker Network use karna
      - PORT=4000
    command: npm run dev # Fastify server + Socket.io + Cron

  worker:
    build: .
    container_name: meme_aggregator_worker
    depends_on:
      - redis
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - .:/app
      - /app/node_modules
    command: npm run worker # BullMQ Worker process

// ----- END FILE: backend/docker-compose.yml -----

// ----- START FILE: backend/src/types/index.ts -----
export interface TokenData {
    token_address: string;
    token_name: string;
    token_ticker: string;
    price_sol: number;
    market_cap_sol: number;
    volume_sol: number;
    liquidity_sol: number;
    transaction_count: number;
    price_1hr_change: number;
    protocol: string; // 'DexScreener' | 'Jupiter'
}

// DexScreener API response structure (partial)
export interface DexScreenerPair {
    chainId: string;
    dexId: string;
    url: string;
    baseToken: {
        address: string;
        name: string;
        symbol: string;
    };
    priceNative: string;
    priceUsd: string;
    volume: {
        h24: number;
    };
    liquidity?: {
        usd: number;
        base: number;
        quote: number;
    };
    priceChange: {
        h1: number;
        h24: number;
    };
}
// ----- END FILE: backend/src/types/index.ts -----

// ----- START FILE: backend/src/sockets/socketManager.ts -----
import { FastifyInstance } from 'fastify';
import { Server, Socket } from 'socket.io'; // <--- Server yahan se aayega
import { createAdapter } from '@socket.io/redis-adapter';
import redis from '../utils/redis';

const UPDATE_CHANNEL = 'token_price_updates';

// Redis Pub/Sub clients
const subClient = redis.duplicate();
const pubClient = redis.duplicate();

// Interface ki ab zaroorat nahi kyunki hum 'io' ko attach kar rahe hain, na ki Fastify se nikal rahe hain.

export const setupSocketIO = (server: FastifyInstance): Server => {

    // 1. Naya Socket.IO Server Instance banao
    const io = new Server(server.server, { // <-- Fastify ka underlying Node.js HTTP server use karo
        cors: {
            origin: '*',
            methods: ['GET', 'POST']
        },
        adapter: createAdapter(pubClient, subClient),
    });

    // 2. Integration logic (baaki sab same)
    io.on('connection', (socket: Socket) => {
        console.log(`[Socket] Client connected: ${socket.id}`);

        // ... (rest of the socket events)
        socket.on('join_discover_room', () => {
            socket.join('discover');
            console.log(`[Socket] Client ${socket.id} joined 'discover' room.`);
        });

        socket.on('disconnect', () => {
            console.log(`[Socket] Client disconnected: ${socket.id}`);
        });
    });

    // Redis Pub/Sub Listener
    subClient.subscribe(UPDATE_CHANNEL, (err) => {
        if (err) console.error("Redis subscription error:", err);
        console.log(`[Socket] Subscribed to Redis channel: ${UPDATE_CHANNEL}`);
    });

    subClient.on('message', (channel, message) => {
        if (channel === UPDATE_CHANNEL) {
            console.log(`[Socket] Received update from Worker: ${message}`);
            io.to('discover').emit('token_update', JSON.parse(message));
        }
    });

    return io;
};

export const socketPublisher = pubClient;
// ----- END FILE: backend/src/sockets/socketManager.ts -----

// ----- START FILE: backend/src/config/env.ts -----
import dotenv from 'dotenv';

dotenv.config();

export const config = {
    PORT: process.env.PORT || 4000,
    REDIS_URL: process.env.REDIS_URL || 'redis://localhost:6379',
    NODE_ENV: process.env.NODE_ENV || 'development',
};
// ----- END FILE: backend/src/config/env.ts -----

// ----- START FILE: backend/src/app.ts -----
import discoverRoutes from './routes/discover'; // <--- New Import
import { setupSocketIO } from './sockets/socketManager';
import Fastify from 'fastify';
import cors from '@fastify/cors';
import { config } from './config/env';
import redis from './utils/redis'; // Importing to trigger connection
import { fetchDexScreenerTokens } from './services/dexProvider';

const app = Fastify({
    logger: true // Development mein logs dekhne ke liye
});

// CORS register karte hain taaki Frontend baat kar sake
app.register(cors, {
    origin: '*', // Production mein isse frontend URL se replace karenge
});

// Discover API route register karna
app.register(discoverRoutes, { prefix: '/api/v1/discover' }); // <--- New Line

// Health Check Route (Resume/Interviews ke liye zaroori)
app.get('/ping', async (request, reply) => {
    // Check if Redis is actually working
    const redisStatus = redis.status === 'ready' ? 'Connected' : 'Disconnected';

    return {
        status: 'API is running ğŸš€',
        redis: redisStatus,
        timestamp: new Date()
    };
});

app.get('/test-fetch', async (request, reply) => {
    const query = (request.query as any).q || 'SOL'; // Default search 'SOL'
    console.log(`ğŸ” Searching for: ${query}`);

    const tokens = await fetchDexScreenerTokens(query);

    return {
        source: 'DexScreener',
        count: tokens.length,
        data: tokens.slice(0, 5) // Sirf top 5 dikhao abhi ke liye
    };
});

const start = async () => {
    try {
        // 1. SOCKET.IO INITIALIZATION: Pehle setup karo
        setupSocketIO(app); // <-- FIX: YE LINE UPAR LE AAYE

        // 2. Fastify server ko listen karwao
        await app.listen({ port: Number(config.PORT), host: '0.0.0.0' });
        console.log(`ğŸš€ Server running at http://localhost:${config.PORT}`);

        // Redis connection check (yeh automatic ho chuka hoga, bas log kar rahe hain)
        console.log("âœ… Redis Connected Successfully");

        // Initial hardcoded jobs add karo (CRON add hone tak)
        const { addTokenFetchJob } = require('./queues/tokenQueue');
        addTokenFetchJob({ tokenAddress: 'ED5nyyWEzpPPiWimP8vYm7sD7TD3LAt3Q3gRTWHzPJBY' });
        addTokenFetchJob({ tokenAddress: '0x28561B8A2360F463011c16b6Cc0B0cbEF8dbBcad' });
    } catch (err) {
        app.log.error(err);
        process.exit(1);
    }
};
// NOTE: Worker ka pub/sub ordering issue Fix 2 se solve ho chuka hai (import time par).

start();
// ----- END FILE: backend/src/app.ts -----

// ----- START FILE: backend/src/utils/pagination.ts -----
import { TokenData } from '../types';

export interface CursorPaginationResult {
    data: TokenData[];
    next_cursor: string | null;
    count: number;
}

// Cursor-based pagination function
export const applyCursorPagination = (
    sortedTokens: TokenData[],
    limit: number,
    cursor: string | undefined
): CursorPaginationResult => {

    let startIndex = 0;

    // Cursor ko base64 se decode karo (Example: tokenAddress)
    if (cursor) {
        try {
            const decodedCursor = Buffer.from(cursor, 'base64').toString('ascii');
            // Hum simply token address ko cursor man rahe hain
            const cursorIndex = sortedTokens.findIndex(t => t.token_address === decodedCursor);
            if (cursorIndex !== -1) {
                startIndex = cursorIndex + 1;
            }
        } catch (e) {
            console.error("Invalid cursor provided.");
        }
    }

    const endIndex = startIndex + limit;
    const pageData = sortedTokens.slice(startIndex, endIndex);

    let nextCursor = null;

    if (endIndex < sortedTokens.length) {
        // Next page ka pehla element ka address encode karo
        nextCursor = Buffer.from(pageData[pageData.length - 1].token_address).toString('base64');
    }

    return {
        data: pageData,
        next_cursor: nextCursor,
        count: pageData.length,
    };
};
// ----- END FILE: backend/src/utils/pagination.ts -----

// ----- START FILE: backend/src/utils/redis.ts -----
import Redis from 'ioredis';
import { config } from '../config/env';

// Redis client instance create kar rahe hain
const redis = new Redis(config.REDIS_URL, {
    maxRetriesPerRequest: null, // BullMQ ke liye zaroori hai
    enableReadyCheck: false
});

redis.on('connect', () => {
    console.log('âœ… Redis Connected Successfully');
});

redis.on('error', (err) => {
    console.error('âŒ Redis Connection Error:', err);
});

export default redis;
// ----- END FILE: backend/src/utils/redis.ts -----

// ----- START FILE: backend/src/queues/connection.ts -----
import { ConnectionOptions } from 'bullmq';
import { config } from '../config/env';

// BullMQ uses Redis, toh hum wohi settings use karenge
export const connection: ConnectionOptions = {
    host: new URL(config.REDIS_URL).hostname,
    port: parseInt(new URL(config.REDIS_URL).port || '6379'),
};
// ----- END FILE: backend/src/queues/connection.ts -----

// ----- START FILE: backend/src/queues/tokenQueue.ts -----
import { Queue, Job } from 'bullmq';
import { connection } from './connection'; // Connection yahan import ho raha hai

// âœ… Re-export connection taaki worker use kar sake
export { connection } from './connection';

// Queue ka naam
export const TOKEN_FETCH_QUEUE = 'TokenFetchQueue';

// Job ka type (token ka address jo hum fetch karna chahte hain)
export interface TokenJobData {
    tokenAddress: string;
}

// Queue instance
export const tokenQueue = new Queue<TokenJobData>(TOKEN_FETCH_QUEUE, {
    connection,
    defaultJobOptions: {
        attempts: 3, // Agar fail ho toh 3 baar retry kare
        backoff: {
            type: 'exponential', // 1s, 2s, 4s ke baad retry
            delay: 1000,
        },
        removeOnComplete: true, // Job khatam hone ke baad queue se hat jaye
        removeOnFail: 5, // Fail hone par 5 din tak record rakhe
    },
});

// Function to add a single job
export const addTokenFetchJob = async (data: TokenJobData) => {
    return tokenQueue.add('fetchTokenDetails', data);
};

// ----- END FILE: backend/src/queues/tokenQueue.ts -----

// ----- START FILE: backend/src/workers/fetchWorker.ts -----
import { socketPublisher } from '../sockets/socketManager';
import { Worker, Job } from 'bullmq';
import { connection, TOKEN_FETCH_QUEUE, TokenJobData } from '../queues/tokenQueue';
import { fetchDexScreenerTokens } from '../services/dexProvider';
import { mergeTokenData } from '../services/aggregator'; // <-- Correct import
import redis from '../utils/redis';

const CACHE_KEY_PREFIX = 'token:merged:';
const CACHE_TTL_SECONDS = 30;

const processTokenJob = async (job: Job<TokenJobData>) => {
    const { tokenAddress } = job.data;

    // 1. Fetch DexScreener data
    const rawSources = await fetchDexScreenerTokens(tokenAddress);
    if (rawSources.length === 0) {
        console.log(`[Worker] No DexScreener data found for ${tokenAddress}`);
        return;
    }

    // 2. Aggregate & Merge with Jupiter price
    const mergedToken = mergeTokenData(rawSources); // <-- FIX: Simple merge use kiya
    if (!mergedToken) {
        throw new Error(`Failed to merge data for ${tokenAddress}`);
    }

    // 3. Save in Redis cache
    const cacheKey = `${CACHE_KEY_PREFIX}${mergedToken.token_address}`;
    await redis.set(cacheKey, JSON.stringify(mergedToken), 'EX', CACHE_TTL_SECONDS);

    // 4. Publish to Socket Server
    await socketPublisher.publish(
        'token_price_updates',
        JSON.stringify(mergedToken)
    );

    console.log(`[Worker] âœ… Processed & Cached: ${mergedToken.token_ticker} | Price: ${mergedToken.price_sol}`);

    return mergedToken;
};

export const tokenWorker = new Worker<TokenJobData>(TOKEN_FETCH_QUEUE, processTokenJob, {
    connection,
    concurrency: 5,
});

tokenWorker.on('failed', (job, err) => {
    console.error(`[Worker] Job ${job?.id} failed with error:`, err);
});

// ----- END FILE: backend/src/workers/fetchWorker.ts -----

// ----- START FILE: backend/src/routes/discover.ts -----
import { FastifyInstance } from 'fastify';
import redis from '../utils/redis';
import { TokenData } from '../types';
import { fetchTokenListAndCache } from '../services/tokenDiscovery';
import { applyCursorPagination, CursorPaginationResult } from '../utils/pagination';

type SortableTokenKeys = 'volume_sol' | 'price_sol' | 'market_cap_sol' | 'liquidity_sol';

export default async function discoverRoutes(app: FastifyInstance) {
    app.get('/', async (request, reply) => {
        const { limit = 20, cursor, sort = 'volume_sol', period = '24h' } = request.query as any;

        const sortKey: SortableTokenKeys = sort as SortableTokenKeys;
        const CACHE_KEY = `discover:list:period=${period}:sort=${sortKey}:limit=${limit}`;

        const cachedList = await redis.get(CACHE_KEY);
        if (cachedList) {
            return JSON.parse(cachedList);
        }

        const keys = await redis.keys('token:merged:*');
        const tokenDataPromises = keys.map(key => redis.get(key));
        const results = await Promise.all(tokenDataPromises);

        const tokens: TokenData[] = results
            .filter(data => data)
            .map(data => JSON.parse(data!));

        const sortedTokens = tokens.sort((a, b) => (b[sortKey] || 0) - (a[sortKey] || 0));

        // Apply cursor-based pagination
        const paginatedResult = applyCursorPagination(sortedTokens, Number(limit), cursor);
        const response: CursorPaginationResult & { next_cursor: string | null } = {
            count: paginatedResult.count,
            next_cursor: paginatedResult.next_cursor,
            data: paginatedResult.data,
        };

        await redis.set(CACHE_KEY, JSON.stringify(response), 'EX', 60);

        return response;
    });
}

// ----- END FILE: backend/src/routes/discover.ts -----

// ----- START FILE: backend/src/services/dexProvider.ts -----
import got from 'got'; // This now points to Got v11
import Bottleneck from 'bottleneck';
import { DexScreenerPair, TokenData } from '../types';

// Rate Limiter Setup (Same as before)
const limiter = new Bottleneck({
    reservoir: 300,
    reservoirRefreshAmount: 300,
    reservoirRefreshInterval: 60 * 1000,
    minTime: 200,
});

const DEXSCREENER_API = 'https://api.dexscreener.com/latest/dex/search';

// Wrapper to handle fetching logic
export const fetchDexScreenerTokens = async (query: string): Promise<TokenData[]> => {
    try {
        // Got v11 ke saath, hum responseType: 'json' use karte hain 
        // aur response.body ko manually type cast karte hain.
        const response = await limiter.schedule(() =>
            got(`${DEXSCREENER_API}?q=${query}`, {
                responseType: 'json',
                timeout: 5000
            })
        );

        // Got v11 mein response.body automatic JSON parse ho chuka hoga
        const data = response.body as { pairs: DexScreenerPair[] };

        if (!data.pairs) return [];

        // Transformation logic (no change)
        return data.pairs.map((pair) => ({
            token_address: pair.baseToken.address,
            token_name: pair.baseToken.name,
            token_ticker: pair.baseToken.symbol,
            price_sol: parseFloat(pair.priceNative),
            market_cap_sol: pair.liquidity?.usd || 0,
            volume_sol: pair.volume.h24,
            liquidity_sol: pair.liquidity?.base || 0,
            transaction_count: 0,
            price_1hr_change: pair.priceChange.h1,
            protocol: `DexScreener (${pair.dexId})`
        }));

    } catch (error) {
        // Yahan hum Got error handling use karenge (error.response.body access karna)
        console.error(`âŒ Error fetching from DexScreener:`, (error as any).response?.body || error);
        return [];
    }
};
// ----- END FILE: backend/src/services/dexProvider.ts -----

// ----- START FILE: backend/src/services/tokenDiscovery.ts -----
// Abhi hum koi fetch nahi kar rahe, bas worker ko trigger karne ka promise return kar rahe hain
export const fetchTokenListAndCache = async (): Promise<boolean> => {
    console.log("[Discovery Service] Triggered, but skipping full fetch until CRON is set.");
    // Yahan hum future mein trending tokens ko fetch karke queue mein daalenge
    // Example: addTokenFetchJob({ tokenAddress: '...' });
    return true;
};
// ----- END FILE: backend/src/services/tokenDiscovery.ts -----

// ----- START FILE: backend/src/services/aggregator.ts -----
import { TokenData } from '../types';

const getCanonicalId = (token: TokenData): string => {
    return token.token_address;
};

export const mergeTokenData = (sources: TokenData[]): TokenData | null => {
    if (sources.length === 0) return null;

    const base = sources[0];
    let totalVolume = 0;
    let totalLiquidity = 0;
    let bestPrice: number = 0;
    let maxLiquidity: number = 0;
    let bestPriceChange: number = base.price_1hr_change;

    const sourceProtocols: string[] = [];

    for (const token of sources) {
        totalVolume += token.volume_sol;
        totalLiquidity += token.liquidity_sol;
        sourceProtocols.push(token.protocol);

        if (token.liquidity_sol > maxLiquidity) {
            maxLiquidity = token.liquidity_sol;
            bestPrice = token.price_sol;
            bestPriceChange = token.price_1hr_change;
        }
    }

    return {
        ...base,
        price_sol: bestPrice || base.price_sol,
        volume_sol: totalVolume,
        liquidity_sol: totalLiquidity,
        price_1hr_change: bestPriceChange,
        protocol: Array.from(new Set(sourceProtocols)).join(', '),
    };
};

// ----- END FILE: backend/src/services/aggregator.ts -----

